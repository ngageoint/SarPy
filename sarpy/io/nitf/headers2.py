# -*- coding: utf-8 -*-
"""
The NITF Header element concrete definitions
"""

import logging
from typing import Union, List

from .base import BaseNITFElement, NITFElement, _StringDescriptor, \
    _StringEnumDescriptor, Unstructured, string_types, int_func
from .tres.registration import find_tre


class NITFSecurityTags(NITFElement):
    """
    The NITF Security Tags object
    """

    _ordering = (
        'CLAS', 'CLSY', 'CODE', 'CTLH', 'REL', 'DCTP', 'DCDT', 'DCXM',
        'DG', 'DGDT', 'CLTX', 'CAPT', 'CAUT', 'CRSN', 'SRDT', 'CTLN')
    _lengths = {
        'CLAS': 1, 'CLSY': 2, 'CODE': 11, 'CTLH': 2,
        'REL': 20, 'DCTP': 2, 'DCDT': 8, 'DCXM': 4,
        'DG': 1, 'DGDT': 8, 'CLTX': 43, 'CAPT': 1,
        'CAUT': 40, 'CRSN': 1, 'SRDT': 8, 'CTLN': 15}
    CLAS = _StringEnumDescriptor(
        'CLAS', True, 1, {'U', 'R', 'C', 'S', 'T'}, default_value='U',
        docstring='The classification level.')
    CLSY = _StringDescriptor(
        'CLSY', True, 2, default_value='',
        docstring='Security Classification System. This field shall contain valid values '
                  'indicating the national or multinational security system used to classify this element. '
                  'Country Codes per FIPS PUB 10-4 shall be used to indicate national security systems. '
                  'The designator "XN" is for classified data generated by a component using NATO security '
                  'system marking guidance. This code is outside the FIPS 10-4 document listing, and was '
                  'selected to not duplicate existing codes.')
    CODE = _StringDescriptor(
        'CODE', True, 11, default_value='',
        docstring='Codewords. This field shall contain a valid indicator of the security '
                  'compartments associated. Valid values include one or more of the digraphs found '
                  'in table A-4. Multiple entries shall be separated by a single ECS spaces (0x20). '
                  'The selection of a relevant set of codewords is application specific.')
    CTLH = _StringDescriptor(
        'CTLH', True, 2, default_value='',
        docstring='Control and Handling. This field shall contain valid additional security control '
                  'and/or handling instructions (caveats) associated with this element.')
    REL = _StringDescriptor(
        'REL', True, 20, default_value='',
        docstring='Releasing Instructions. This field shall contain a valid list of country and/or '
                  'multilateral entity codes to which countries and/or multilateral entities this element'
                  'is authorized for release. Valid items in the list are one or more country codes as '
                  'found in FIPS PUB 10-4 and/or codes identifying multilateral entities.')
    DCTP = _StringEnumDescriptor(
        'DCTP', True, 2, {'', 'DD', 'DE', 'GD', 'GE', 'O', 'X'}, default_value='',
        docstring='Declassification Type. This field shall contain a valid indicator of the type of '
                  'security declassification or downgrading instructions which apply to this element.')
    DCDT = _StringDescriptor(
        'DCDT', True, 8, default_value='',
        docstring='Declassification Date. This field shall indicate the date on which this element '
                  'is to be declassified if the value in Declassification Type is `"DD"`.')
    DCXM = _StringEnumDescriptor(
        'DCXM', True, 4,
        {'', 'X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8',
         'X251', 'X252', 'X253', 'X254', 'X255', 'X256', 'X257', 'X258'}, default_value='',
        docstring='Declassification Exemption. This field shall indicate the reason this element is '
                  'exempt from automatic declassification if the value in Declassification '
                  'Type is X.')
    DG = _StringEnumDescriptor(
        'DG', True, 1, {'', 'S', 'C', 'R'}, default_value='',
        docstring='Downgrade. This field shall indicate the classification level to which this element is to '
                  'be downgraded if the values in Declassification Type are GD or GE.')
    DGDT = _StringDescriptor(
        'DGDT', True, 8, default_value='',
        docstring='Downgrade Date. This field shall indicate the date on which this element is to be downgraded '
                  'if the value in Declassification Type is GD.')
    CLTX = _StringDescriptor(
        'CLTX', True, 43, default_value='',
        docstring='Classification Text. This field shall be used to provide additional information about '
                  'classification to include identification of a declassification or downgrading event if the '
                  'values in Declassification Type are DE or GE. It may also be used to identify multiple '
                  'classification sources and/or any other special handling rules. Values are user defined free text.')
    CAPT = _StringEnumDescriptor(
        'CAPT', True, 1, {'', 'O', 'D', 'M'}, default_value='',
        docstring='Classification Authority Type. This field shall indicate the type of authority '
                  'used to classify this element.')
    CAUT = _StringDescriptor(
        'CAUT', True, 40, default_value='',
        docstring='Classification Authority. This field shall identify the classification authority '
                  'for this element dependent upon the value in Classification Authority Type. Values are user '
                  'defined free text which should contain the following information: original classification '
                  'authority name and position or personal identifier if the value in Classification Authority '
                  'Type is O; title of the document or security classification guide used to classify this element '
                  'if the value in Classification Authority Type is D; and Derive-Multiple if the classification '
                  'was derived from multiple sources. In the latter case, the originator will maintain a record '
                  'of the sources used in accordance with existing security directives. One of the multiple '
                  'sources may also be identified in Classification Text if desired')
    CRSN = _StringEnumDescriptor(
        'CRSN', True, 1, {'', 'A', 'B', 'C', 'D', 'E', 'F', 'G'}, default_value='',
        docstring='Classification Reason. This field shall contain values indicating the reason for '
                  'classifying the graphic. Valid values are A to G. These correspond to the reasons for '
                  'original classification per E.O. 12958, Section 1.5.(a) to (g).')
    SRDT = _StringDescriptor(
        'SRDT', True, 8, default_value='',
        docstring='Security Source Date. This field shall indicate the date of the source used to derive '
                  'the classification of the graphic. In the case of multiple sources, the date of the '
                  'most recent source shall be used.')
    CTLN = _StringDescriptor(
        'CTLN', True, 15, default_value='',
        docstring='Security Control Number. This field shall contain a valid security control number '
                  'associated with the graphic. The format of the security control number shall be in '
                  'accordance with the regulations governing the appropriate security channel(s).')


######
# TRE Elements

class TRE(BaseNITFElement):
    """
    An abstract TRE class - this should not be instantiated directly.
    """

    @property
    def TAG(self):
        """
        The TRE tag.

        Returns
        -------
        str
        """

        raise NotImplementedError

    @property
    def DATA(self):
        """
        The TRE data.

        Returns
        -------

        """

        raise NotImplementedError

    @property
    def EL(self):
        """
        The TRE element length.

        Returns
        -------
        int
        """

        raise NotImplementedError

    def get_bytes_length(self):
        raise NotImplementedError

    def to_bytes(self):
        raise NotImplementedError

    @classmethod
    def minimum_length(cls):
        return 11

    @classmethod
    def from_bytes(cls, value, start):
        tag = value[start:start+6]
        known_tre = find_tre(tag)
        if known_tre is not None:
            try:
                return known_tre.from_bytes(value, start)
            except Exception as e:
                logging.error(
                    "Failed parsing tre as type {} with error {}. "
                    "Returning unparsed.".format(known_tre.__name__, e))
        return UnknownTRE.from_bytes(value, start)


class UnknownTRE(TRE):
    __slots__ = ('_TAG', '_data')

    def __init__(self, TAG, data):
        """

        Parameters
        ----------
        TAG : str
        data : bytes
        """

        self._data = None
        if isinstance(TAG, bytes):
            TAG = TAG.decode('utf-8')

        if not isinstance(TAG, string_types):
            raise TypeError('TAG must be a string. Got {}'.format(type(TAG)))
        if len(TAG) > 6:
            raise ValueError('TAG must be 6 or fewer characters')

        self._TAG = TAG
        self.data = data

    @property
    def TAG(self):
        return self._TAG

    @property
    def DATA(self):  # type: () -> bytes
        return self._data

    @DATA.setter
    def DATA(self, value):
        if not isinstance(value, bytes):
            raise TypeError('data must be a bytes instance. Got {}'.format(type(value)))
        self._data = value

    @property
    def EL(self):
        return len(self._data)

    def get_bytes_length(self):
        return 11 + self.EL

    def to_bytes(self):
        return '{0:6s}{1:05d}'.format(self.TAG, self.EL).encode('utf-8') + self._data

    @classmethod
    def from_bytes(cls, value, start):
        tag = value[start:start+6]
        lng = int_func(value[start+6:start+11])
        return cls(tag, value[start+11:start+11+lng])


class TREList(NITFElement):
    """
    A list of TREs. This is meant to be used indirectly through one of the header
    type objects, which controls the parsing appropriately.
    """

    __slots__ = ('_tres', )
    _ordering = ('tres', )

    def __init__(self, tres=None, **kwargs):
        self._tres = []
        super(TREList, self).__init__(tres=tres, **kwargs)

    @property
    def tres(self):  # type: () -> List[TRE]
        return self._tres

    @tres.setter
    def tres(self, value):
        if value is None:
            self._tres = []
            return

        if not isinstance(value, (list, tuple)):
            raise TypeError('tres must be a list or tuple')

        for i, entry in enumerate(value):
            if not isinstance(entry, TRE):
                raise TypeError(
                    'Each entry of tres must be of type TRE. '
                    'Entry {} is type {}'.format(i, type(entry)))
        self._tres = value

    def _get_attribute_bytes(self, attribute):
        if attribute == 'tres':
            if len(self._tres) == 0:
                return b''
            return b''.join(entry.to_bytes() for entry in self._tres)
        return super(TREList, self)._get_attribute_bytes(attribute)

    def _get_attribute_length(self, attribute):
        if attribute == 'tres':
            if len(self._tres) == 0:
                return 0
            return sum(entry.get_bytes_length() for entry in self._tres)
        return super(TREList, self)._get_attribute_length(attribute)

    @classmethod
    def _parse_attribute(cls, fields, attribute, value, start):
        if attribute == 'tres':
            if len(value) == start:
                fields['tres'] = []
                return start
            tres = []
            loc = start
            while loc < len(value):
                tre = TRE.from_bytes(value, loc)
                loc += tre.get_bytes_length()
                tres.append(tre)
            fields['tres'] = tres
            return len(value)
        return super(TREList, cls)._parse_attribute(fields, attribute, value, start)

    def __len__(self):
        return len(self._tres)

    def __getitem__(self, item):  # type: (Union[int, slice]) -> Union[TRE, List[TRE]]
        return self._tres[item]


class TREHeader(Unstructured):
    def _populate_data(self):
        if isinstance(self._data, bytes):
            data = TREList.from_bytes(self._data, 0)
            self._data = data


class UserHeaderType(Unstructured):
    __slots__ = ('_data', '_ofl')
    _ordering = ('data', )
    _size_len = 5
    _ofl_len = 3

    def __init__(self, OFL=None, data=None, **kwargs):
        self._ofl = None
        self._data = None
        self.OFL = OFL
        super(UserHeaderType, self).__init__(data=data, **kwargs)

    @property
    def OFL(self):  # type: () -> int
        return self._ofl

    @OFL.setter
    def OFL(self, value):
        if value is None:
            self._ofl = 0
            return

        value = int_func(value)
        if not (0 <= value <= 999):
            raise ValueError('ofl requires an integer value in the range 0-999.')
        self._ofl = value

    def _populate_data(self):
        if isinstance(self._data, bytes):
            data = TREList.from_bytes(self._data, 0)
            self._data = data

    @classmethod
    def minimum_length(cls):
        return cls._size_len

    def _get_attribute_bytes(self, attribute):
        if attribute == 'data':
            siz_frm = '{0:0' + str(self._size_len) + '}'
            ofl_frm = '{0:0' + str(self._ofl_len) + '}'
            data = self.data
            if data is None:
                return b'0'*self._size_len
            if isinstance(data, NITFElement):
                data = data.to_bytes()
            if isinstance(data, bytes):
                return siz_frm.format(len(data) + self._ofl_len).encode('utf-8') + \
                    ofl_frm.format(self._ofl).encode('utf-8') + data
            else:
                raise TypeError('Got unexpected data type {}'.format(type(data)))
        return super(Unstructured, self)._get_attribute_bytes(attribute)

    def _get_attribute_length(self, attribute):
        if attribute == 'data':
            data = self.data
            if data is None:
                return self._size_len
            elif isinstance(data, NITFElement):
                return self._size_len + self._ofl_len + data.get_bytes_length()
            else:
                return self._size_len + self._ofl_len + len(data)
        return super(UserHeaderType, self)._get_attribute_length(attribute)

    @classmethod
    def _parse_attribute(cls, fields, attribute, value, start):
        if attribute == 'data':
            length = int_func(value[start:start + cls._size_len])
            start += cls._size_len
            if length > 0:
                ofl = int_func(value[start:start+cls._ofl_len])
                fields['OFL'] = ofl
                fields['data'] = value[start+cls._ofl_len:start + length]
            else:
                fields['OFL'] = 0
                fields['data'] = None
            return start + length
        return super(UserHeaderType, cls)._parse_attribute(fields, attribute, value, start)
